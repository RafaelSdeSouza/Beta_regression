corr<-Corr_MIC(SNIa,"pearson")
Fig1<-plotdendrogram(corr,"phylogram")
install_github("RafaelSdeSouza/AMADA",dependencies=TRUE)
require(devtools)
install_github("RafaelSdeSouza/AMADA",dependencies=TRUE)
help("AMADA")
?AMADA
?"AMADA"
vignette("AMADA")
R CMD Rd2pdf AMADA
library(help="AMADA")
help("AMADA")
help(package="AMADA")
N = 10
M= 3
matrix(rnorm(N*M,mean=0,sd=1), N, M)
N = 100
M= 1000
M1<-matrix(rnorm(N*M,mean=0,sd=1), N, M)
M1
N = 10000
M= 1000
M1<-matrix(rnorm(N*M,mean=0,sd=1), N, M)
corr<-Corr_MIC(M1,"pearson")
Fig1<-plotdendrogram(corr,"phylogram")
corr
Fig1<-plotdendrogram(corr,"fan")
N = 5000
M= 100
M1<-matrix(rnorm(N*M,mean=0,sd=1), N, M)
corr<-Corr_MIC(M1,"pearson")
Fig1<-plotdendrogram(corr,"fan")
N = 5000
M= 500
M1<-matrix(rnorm(N*M,mean=0,sd=1), N, M)
corr<-Corr_MIC(M1,"pearson")
Fig1<-plotdendrogram(corr,"fan")
N = 5000
M= 100
M1<-matrix(rnorm(N*M,mean=0,sd=1), N, M)
corr<-Corr_MIC(M1,"pearson")
Fig1<-plotdendrogram(corr,"fan")
N = 50000
M= 100
M1<-matrix(rnorm(N*M,mean=0,sd=1), N, M)
corr<-Corr_MIC(M1,"pearson")
Fig1<-plotdendrogram(corr,"fan")
N = 100000
M= 100
M1<-matrix(rnorm(N*M,mean=0,sd=1), N, M)
corr<-Corr_MIC(M1,"pearson")
Fig1<-plotdendrogram(corr,"fan")
ptm <- proc.time()
corr<-Corr_MIC(M1,"pearson")
Fig1<-plotdendrogram(corr,"fan")
proc.time() - ptm
1.432+0.044
help(package="AMADA")
install.packages("GGally")
library("GGally", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
data(diamonds, package="ggplot2")
diamonds.samp <- diamonds[sample(1:dim(diamonds)[1],200),]
# Custom Example
pm <- ggpairs(
diamonds.samp[,1:3],
upper = list(continuous = "density", combo = "box"),
lower = list(continuous = "points", combo = "dot"),
color = "cut",
title = "Diamonds"
)
pm
pm <- ggpairs(
diamonds.samp[,1:3],
upper = list(continuous = "density", combo = "box"),
lower = list(continuous = "density", combo = "dot"),
color = "cut",
title = "Diamonds"
)
pm
ggpairs(
diamonds.samp[,1:3],
upper = list(continuous = "density", combo = "box"),
lower = list(continuous = "density"),
color = "cut",
title = "Diamonds"
)
ggpairs(
diamonds.samp[,1:3],
upper = list(continuous = "density"),
lower = list(continuous = "density"),
color = "cut",
title = "Diamonds"
)
ggpairs(
iris[,1:4],
upper = list(continuous = "density"),
lower = list(continuous = "density"),
color = "cut",
title = "Diamonds"
)
ggpairs(
iris[,1:4],
upper = list(continuous = "density"),
lower = list(continuous = "density")
)
ggpairs(
iris[,1:4],
upper = list(continuous = "cor"),
lower = list(continuous = "density")
)
pm <- ggpairs(
iris[,1:4],
upper = list(continuous = "cor"),
lower = list(continuous = "density"),
diag=list("density")
)
pm
ggpairs(
iris[,1:4],
upper = list(continuous = "cor"),
lower = list(continuous = "density"),
diag=list("bar'")
)
pm <- ggpairs(
iris[,1:4],
diag=list("bar"),
upper = list(continuous = "cor"),
lower = list(continuous = "density")
)
pm
pm <- ggpairs(
iris[,1:4],
diag=list("bar"),
upper = list(continuous = "cor"),
lower = list(continuous = "hist")
)
pm
pm <- ggpairs(
iris[,1:4],
diag=list("continuous"),
upper = list(continuous = "cor"),
lower = list(continuous = "density")
)
pm
install.packages("R1magic")
library(R1magic)#  Signal components
N <- 100
# Sparse components
K <- 4
#  Up to Measurements  > K LOG (N/K)
M <- 40
# Measurement Matrix (Random Sampling Sampling)
phi <- GaussianMatrix(N,M)
# R1magic generate random signal
xorg <- sparseSignal(N, K, nlev=1e-3)
y <- phi %*% xorg ;# generate measurement
T <- diag(N) ;# Do identity transform
p <- matrix(0, N, 1) ;# initial guess
# R1magic Convex Minimization ! (unoptimized-parameter)
ll <- solveL1(phi, y, T, p)
x1 <- ll$estimate
plot( 1:100, seq(0.011,1.1,0.011), type = “n”,xlab=””,ylab=””)
title(main=”Random Sparse Signal Recovery”,
xlab=”Signal Component”,ylab=”Spike Value”)
lines(1:100, xorg , col = “red”)
lines(1:100, x1, col = “blue”, cex = 1.5)
# shifted by 5 for clearity
library(R1magic)#  Signal components
N <- 100
# Sparse components
K <- 4
#  Up to Measurements  > K LOG (N/K)
M <- 40
# Measurement Matrix (Random Sampling Sampling)
phi <- GaussianMatrix(N,M)
# R1magic generate random signal
xorg <- sparseSignal(N, K, nlev=1e-3)
y <- phi %*% xorg ;# generate measurement
T <- diag(N) ;# Do identity transform
p <- matrix(0, N, 1) ;# initial guess
# R1magic Convex Minimization ! (unoptimized-parameter)
ll <- solveL1(phi, y, T, p)
x1 <- ll$estimate
plot( 1:100, seq(0.011,1.1,0.011), type = "n",xlab="",ylab="")
title(main="Random Sparse Signal Recovery",
xlab="Signal Component",ylab="Spike Value")
lines(1:100, xorg , col = "red")
lines(1:100, x1, col = “blue”, cex = 1.5)
# shifted by 5 for clearity
library(R1magic)#  Signal components
N <- 100
# Sparse components
K <- 4
#  Up to Measurements  > K LOG (N/K)
M <- 40
# Measurement Matrix (Random Sampling Sampling)
phi <- GaussianMatrix(N,M)
# R1magic generate random signal
xorg <- sparseSignal(N, K, nlev=1e-3)
y <- phi %*% xorg ;# generate measurement
T <- diag(N) ;# Do identity transform
p <- matrix(0, N, 1) ;# initial guess
# R1magic Convex Minimization ! (unoptimized-parameter)
ll <- solveL1(phi, y, T, p)
x1 <- ll$estimate
plot( 1:100, seq(0.011,1.1,0.011), type = "n",xlab="",ylab="")
title(main="Random Sparse Signal Recovery",
xlab="Signal Component",ylab="Spike Value")
lines(1:100, xorg , col = "red")
lines(1:100, x1, col = "blue", cex = 1.5)
xorg
x1
phi
y
diag(N)
matrix(0, N, 1)
5.226/2.760
1.893478*0.74
setwd("~/Dropbox/artigos/Meusartigos/IAA-WGC/Github/Beta_regression")
#  JAGS script  Scape_Fraction.R
#  Copyright (C) 2015  Rafael S. de Souza
#
#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License version 3 as published by
#the Free Software Foundation.
#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#  A copy of the GNU General Public License is available at
#  http://www.r-project.org/Licenses/
#
#  Required libraries
library(rjags)
library(ggmcmc)
library(ggplot2)
library(ggthemes)
library(pander)
library(Cairo)
library(plyr)
library(MASS)
library(scales)
library(plyr)
require(gdata)
require(runjags)
require(gdata)
require(caret)
require(pROC)
require(plyr)
#Read the  dataset
data.1= read.table(file="FiBY_escape_data_all.dat",header=FALSE)
colnames(data.1)<-c("redshift","fEsc","Mvir","Mstar","Mgas","QHI","sfr_gas",
"sfr_stars","ssfr_gas","ssfr_stars","baryon_fraction",
"spin","age_star_mean","age_star_max","age_star_min","NH_10")
#trainIndex <- createDataPartition(data.1$redshift, p = .25,
#                                  list = FALSE,
#                                  times = 1)
data.2<-data.1[data.1$redshift<=10,]
#data.2<-data.1[trainIndex,]
#data.2<-data.1[data.1$redshift==8.86815,]
#data.2<-data.1
N<-nrow(data.2)
data.2$Y<-(data.2$fEsc*(N-1)+0.5)/N
data.2$Y[data.2$Y>=0.1]<-1
data.2$Y[data.2$Y<0.1]<-0
#data.2$Y<-as.factor(data.2$Y)
# Prepare data for JAGS
data.2$Mstar<-(data.2$Mstar-mean(data.2$Mstar))/sd(data.2$Mstar)
data.2$Mgas<-(data.2$Mgas-mean(data.2$Mgas))/sd(data.2$Mgas)
data.2$Mvir<-(data.2$Mvir-mean(data.2$Mvir))/sd(data.2$Mvir)
data.2$sfr_gas<-(data.2$sfr_gas-mean(data.2$sfr_gas))/sd(data.2$sfr_gas)
data.2$baryon_fraction<-(data.2$baryon_fraction-mean(data.2$baryon_fraction))/sd(data.2$baryon_fraction)
data.2$QHI<-(data.2$QHI-mean(data.2$QHI))/sd(data.2$QHI)
data.2$ssfr_gas<-(data.2$ssfr_gas-mean(data.2$ssfr_gas))/sd(data.2$ssfr_gas)
data.2$age_star_mean<-(data.2$age_star_mean-mean(data.2$age_star_mean))/sd(data.2$age_star_mean)
data.2$spin<-(data.2$spin-mean(data.2$spin))/sd(data.2$spin)
data.2$NH_10<-(data.2$NH_10-mean(data.2$NH_10))/sd(data.2$NH_10)
fit=glm(Y~QHI+baryon_fraction,data=data.2,family=binomial("logit"))
predict(fit, type="response")
ROC<-roc(predict(fit, type="response"), data.2$Y)
ROC
fit=glm(Y~baryon_fraction,data=data.2,family=binomial("logit"))
ROC<-roc(predict(fit, type="response"), data.2$Y)
ROC
fit
library(popbio)
logi.hist.plot(data.2$baryon_fraction ,data.2$Y,boxp=F,type="hist",counts = T,col="gray",xlabel = expression(f[gas]),ylabel="Probability")
fit=glm(Y~spin,data=data.2,family=binomial("logit"))
ROC<-roc(predict(fit, type="response"), data.2$Y)
ROC<
data.2$spin
ROC
fit=glm(Y~age_star_mean,data=data.2,family=binomial("logit"))
ROC<-roc(predict(fit, type="response"), data.2$Y)
ROC
fit=glm(Y~Mvir,data=data.2,family=binomial("logit"))
ROC<-roc(predict(fit, type="response"), data.2$Y)
ROC
fit=glm(Y~Mvir+Mgas,data=data.2,family=binomial("logit"))
ROC<-roc(predict(fit, type="response"), data.2$Y)
ROC
fit
fit=glm(Y~Mvir+Mgas+QI,data=data.2,family=binomial("logit"))
ROC<-roc(predict(fit, type="response"), data.2$Y)
ROC
fit=glm(Y~Mvir+Mgas+QII,data=data.2,family=binomial("logit"))
ROC<-roc(predict(fit, type="response"), data.2$Y)
ROC
fit=glm(Y~Mvir+Mgas+QHI,data=data.2,family=binomial("logit"))
ROC<-roc(predict(fit, type="response"), data.2$Y)
ROC
fit=glm(Y~QHI,data=data.2,family=binomial("logit"))
ROC<-roc(predict(fit, type="response"), data.2$Y)
ROC
fit=glm(Y~QHI,data=data.2,family=binomial("logit"))
ROC<-roc(predict(fit, type="response"), data.2$Y)
ROC
fit=glm(Y~QHI,data=data.2,family=binomial("logit"))
ROC<-roc(predict(fit, type="response"), data.2$Y)
ROC
fit=glm(Y~baryon_fraction,data=data.2,family=binomial("logit"))
ROC<-roc(predict(fit, type="response"), data.2$Y)
ROC
require(LOGIT)
ROCtest(fit)
fit=glm(Y~QHI+baryon_fraction,data=data.2,family=binomial("logit"))
ROCtest(fit)
hlGOF.test(data.2$Y, predict(fit,data.2, type="response"), breaks=12)
fit=glm(Y~"Mvir","baryon_fraction","ssfr_gas","age_star_mean","spin","NH_10",data=data.2,family=binomial("logit"))
ROCtest(fit)
fit2=glm(Y~Mvir+baryon_fraction+age_star_mean+ssfr_gas,data=data.2,family=binomial("logit"))
ROCtest(fit2,10,"ROC")
fit2
fit2=glm(Y~redshift+Mvir+baryon_fraction+age_star_mean+ssfr_gas,data=data.2,family=binomial("logit"))
ROCtest(fit2,10,"ROC")
library(lme4)
library(nlme)
library(arm)
fit2=glmer(Y~Mvir+baryon_fraction+age_star_mean+ssfr_gas+(1|redshift),data=data.2,family=binomial("logit"))
fit2
ROCtest(fit2,10,"ROC")
predict(fit2,type=response)
predict(fit2,type="response")
roc(predict(fit2,type="response"), data.2$Y)
fit2=glmer(Y~Mvir+baryon_fraction+(1|redshift),data=data.2,family=binomial("logit"))
predict(fit2,type="response")
roc(predict(fit2,type="response"), data.2$Y)
fit2
glm(Y~Mvir+baryon_fraction,data=data.2,family=binomial("logit"))
require(gam)
fit2=gam(Y~Mvir+baryon_fraction,data=data.2,family=binomial("logit"))
roc(predict(fit2,type="response"), data.2$Y)
fit2
ROCtest(fit2,10,"ROC")
fit=glm(Y~Mvir+baryon_fraction,data=data.2,family=binomial("probit"))
ROCtest(fit,10,"ROC")
fit2=gam(Y~Mvir+baryon_fraction,data=data.2,family=binomial("logit"))
ROCtest(fit2,10,"ROC")
install.packages("gammSlice")
require(gammSlice)
fit2=gSlc(Y~s(Mvir)+s(baryon_fraction),data=data.2,family=binomial("logit"))
fit2
plot(fit2)
fit2=gam(Y~s(Mvir)+s(baryon_fraction),data=data.2,family=binomial("logit"))
plot(fit2)
plot(fit2)
plot(fit2)
vis.gam(fit2,type="response")
vis.gam(fit2,type="response",plot.type = "countour")
vis.gam(fit2,type="response",plot.type = "countour")
vis.gam(fit2,type="response",plot.type = "countour")
vis.gam(fit2,type="response",plot.type = "contour")
fit2=gam(Y~te(Mvir,baryon_fraction),data=data.2,family=binomial("logit"))
vis.gam(fit2,type="response",plot.type = "contour")
vis.gam(fit2,type="response",plot.type = "persp")
vis.gam(fit2,type="response",plot.type = "persp", border=NA, n.grid=500,theta=30,phi=30)
vis.gam(fit2,type="response",plot.type = "persp", border=NA, n.grid=500,theta=50,phi=30)
vis.gam(fit2,type="response",plot.type = "persp", border=NA, n.grid=500,theta=10,phi=30)
vis.gam(fit2,type="response",plot.type = "persp", border=NA, n.grid=500,theta=-10,phi=30)
vis.gam(fit2,type="response",plot.type = "persp", border=NA, n.grid=500,theta=-30,phi=30)
vis.gam(fit2,type="response",plot.type = "persp", border=NA, n.grid=500,theta=-60,phi=30)
logi.hist.plot(data.2$baryon_fraction ,data.2$Y,boxp=F,type="hist",counts = T,col="gray",xlabel = expression(f[gas]),ylabel="Probability")
logi.hist.plot(data.2$Mvir ,data.2$Y,boxp=F,type="hist",counts = T,col="gray",xlabel = expression(f[gas]),ylabel="Probability")
vis.gam(fit2,type="response",plot.type = "persp", border=NA, n.grid=500,theta=-60,phi=30)
fit2=gam(Y~s(Mvir)+s(baryon_fraction),data=data.2,family=binomial("logit"))
vis.gam(fit2,type="response",plot.type = "persp", border=NA, n.grid=500,theta=-60,phi=30)
fit2=gam(Y~te(QHI,baryon_fraction),data=data.2,family=binomial("logit"))
vis.gam(fit2,type="response",plot.type = "persp", border=NA, n.grid=500,theta=-60,phi=30)
vis.gam(fit2,type="response",plot.type = "persp",color="topo", border=NA, n.grid=500,theta=-60,phi=30)
vis.gam(fit2,type="response",plot.type = "persp",color="topo", n.grid=500,theta=-60,phi=30)
vis.gam(fit2,type="response",plot.type = "persp",color="topo", border=NA, n.grid=500,theta=-60,phi=30)
vis.gam(fit,type="response",plot.type = "persp",color="topo", border=NA, n.grid=500,theta=-60,phi=30)
fit=glm(Y~Mvir+baryon_fraction,data=data.2,family=binomial("probit"))
vis.gam(fit,type="response",plot.type = "persp",color="topo", border=NA, n.grid=500,theta=-60,phi=30)
setwd("~/Dropbox/artigos/Meusartigos/IAA-WGC/Github/Beta_regression")
#  Required libraries
library(rjags)
library(ggmcmc)
library(ggplot2)
library(ggthemes)
library(pander)
library(Cairo)
library(plyr)
library(MASS)
library(scales)
library(plyr)
require(gdata)
require(runjags)
require(gdata)
require(caret)
require(pROC)
require(plyr)
require(LOGIT)
require(usdm)
library(lme4)
library(nlme)
library(arm)
require(gam)
#Read the  dataset
data.1= read.table(file="FiBY_escape_data_all.dat",header=FALSE)
colnames(data.1)<-c("redshift","fEsc","Mvir","Mstar","Mgas","QHI","sfr_gas",
"sfr_stars","ssfr_gas","ssfr_stars","baryon_fraction",
"spin","age_star_mean","age_star_max","age_star_min","NH_10")
#trainIndex <- createDataPartition(data.1$redshift, p = .25,
#                                  list = FALSE,
#                                  times = 1)
data.2<-data.1[data.1$redshift<=12,]
data.2<-data.1[trainIndex,]
#data.2<-data.1[data.1$redshift==8.86815,]
#data.2<-data.1
N<-nrow(data.2)
data.2$Y<-(data.2$fEsc*(N-1)+0.5)/N
data.2$Y[data.2$Y>=0.1]<-1
data.2$Y[data.2$Y<0.1]<-0
#data.2$Y<-as.factor(data.2$Y)
vifcor(data.2[,c("Mvir","baryon_fraction","ssfr_gas","age_star_mean","spin","NH_10")],th=0.7)
x<-data.2[,c("Mvir","baryon_fraction","ssfr_gas","age_star_mean","spin","NH_10")]
cor<-Corr_MIC(x,"pearson")
plotgraph(cor)
# Prepare data for JAGS
data.2$Mstar<-(data.2$Mstar-mean(data.2$Mstar))/sd(data.2$Mstar)
data.2$Mgas<-(data.2$Mgas-mean(data.2$Mgas))/sd(data.2$Mgas)
data.2$Mvir<-(data.2$Mvir-mean(data.2$Mvir))/sd(data.2$Mvir)
data.2$sfr_gas<-(data.2$sfr_gas-mean(data.2$sfr_gas))/sd(data.2$sfr_gas)
data.2$baryon_fraction<-(data.2$baryon_fraction-mean(data.2$baryon_fraction))/sd(data.2$baryon_fraction)
data.2$QHI<-(data.2$QHI-mean(data.2$QHI))/sd(data.2$QHI)
data.2$ssfr_gas<-(data.2$ssfr_gas-mean(data.2$ssfr_gas))/sd(data.2$ssfr_gas)
data.2$age_star_mean<-(data.2$age_star_mean-mean(data.2$age_star_mean))/sd(data.2$age_star_mean)
data.2$spin<-(data.2$spin-mean(data.2$spin))/sd(data.2$spin)
data.2$NH_10<-(data.2$NH_10-mean(data.2$NH_10))/sd(data.2$NH_10)
data.2$sfr_stars<-(data.2$sfr_stars-mean(data.2$sfr_stars))/sd(data.2$sfr_stars)
x2<-as.matrix(data.2[,c("redshift","Mvir","baryon_fraction","ssfr_gas","age_star_mean","spin","NH_10")])
#fit=glm(Y~QHI+baryon_fraction+redshift,data=data.2,family=binomial("probit"))
fit<-glmnet(x2,y=data.2$Y,alpha=1,family="binomial")
require(glmnet)
fit<-glmnet(x2,y=data.2$Y,alpha=1,family="binomial")
fit
plot(fit,xvar="lambda",label = TRUE)
plot(fit, xvar = "dev", label = TRUE)
cv.glmmod <- cv.glmnet(x2,y=data.2$Y,alpha=1,family="binomial",type.measure = "auc")
plot(cv.glmmod)
best_lambda <- cv.glmmod$lambda.min
coef.min = coef(cv.glmmod, s = "lambda.min")
active.min = coef.min[which(abs(coef.min) > 0.1)]
active.min
coef.min
exp(0.05)
exp(0.05)/(1-exp(0.05))
exp(1)/(1-exp(1))
exp(1)/(1+exp(1))
exp(0.05)/(1+exp(0.05))
exp(0.01)/(1+exp(0.01))
exp(0.01)
exp(0.001)
p.coeff(-0.54)
p.coeff<-function(coeff){(exp(coeff)/(1+exp(coeff)))}
p.coeff(-0.54)
p.coeff(-0.02)
p.coeff(0.02)
p.coeff(.97)
p.coeff(3.73)
p.coeff(1e-6)
p.coeff(0)
p.coeff(-6)
coef(fit)
ROCtest(fit,10,"ROC")
fit
best_lambda
cv.glmmod <- cv.glmnet(x2,y=data.2$Y,alpha=1,family="binomial")
plot(cv.glmmod)
best_lambda <- cv.glmmod$lambda.min
best_lambda
x2<-as.matrix(data.2[,c("Mvir","baryon_fraction","ssfr_gas","age_star_mean","spin","NH_10")])
#fit=glm(Y~QHI+baryon_fraction+redshift,data=data.2,family=binomial("probit"))
fit<-glmnet(x2,y=data.2$Y,alpha=1,family="binomial")
cv.glmmod <- cv.glmnet(x2,y=data.2$Y,alpha=1,family="binomial")
plot(cv.glmmod)
best_lambda <- cv.glmmod$lambda.min
best_lambda
cv.glmmod <- cv.glmnet(x2,y=data.2$Y,alpha=1,family="binomial",type.measure = "class")
plot(cv.glmmod)
cv.glmmod <- cv.glmnet(x2,y=data.2$Y,alpha=1,family="binomial",type.measure = "auc")
plot(cv.glmmod)
best_lambda <- cv.glmmod$lambda.min
best_lambda
coef.min = coef(cv.glmmod, s = "lambda.min")
active.min = coef.min[which(abs(coef.min) > 0.05)]
coef.min
active.min = coef.min[which(abs(coef.min) > 0.05)]
active.min
p.coeff(0.02)
p.coeff(0.024)
