## Start a local cluster with 2GB RAM
localH2O = h2o.init(ip = "localhost", port = 54321, startH2O = TRUE,
Xmx = '2g')
dat <- BreastCancer[, -1]  # remove the ID column
dat_h2o <- as.h2o(localH2O, dat, key = 'dat')
## Import MNIST CSV as H2O
dat_h2o <- h2o.importFile(localH2O, path = ".../mnist_train.csv")
dat_h2o
dat
BreastCancer[, -1]
localH2O
library(h2o)
localH2O = h2o.init()
irisPath = system.file("extdata", "iris.csv", package = "h2o")
iris.hex = h2o.importFile(localH2O, path = irisPath)
h2o.deeplearning(x = 1:4, y = 5, data = iris.hex, activation = "Tanh",
hidden = c(10, 10), epochs = 5)
data.hex = h2o.importFile(
localH2O,
path = "https://raw.github.com/0xdata/h2o/master/smalldata/bank-additional-full.csv",
key = "data.hex")
myX = 1:20
myY="y"
my.dl = h2o.deeplearning(x=myX,y=myY,data=data.hex,classification=T,activation="Tanh",
hidden=c(10,10,10),epochs=12,variable_importances=T)
dl.VI =my.dl@model$varimp
print(dl.VI)
dl.VI
iris.hex
localH2O
localH2O = h2o.init(ip = "localhost", port = 54321, startH2O = TRUE,
Xmx = '16g')
localH2O = h2o.init(ip = "localhost", port = 54321, startH2O = TRUE,
max_mem_size = '16g')
localH2O = h2o.init(ip = "localhost", port = 54321, startH2O = TRUE,
max_mem_size = '16g',nthreads=4)
localH2O
h2o.init(ip = "localhost", port = 54321, startH2O = TRUE,
max_mem_size = '16g',nthreads=4)
library(h2o)
localH2O = h2o.init(ip = "localhost", port = 54321, startH2O = TRUE,
max_mem_size = '16g',nthreads=-1)
irisPath = system.file("extdata", "iris.csv", package = "h2o")
iris.hex = h2o.importFile(localH2O, path = irisPath)
h2o.deeplearning(x = 1:4, y = 5, data = iris.hex, activation = "Tanh",
hidden = c(10, 10), epochs = 5)
h2o.init(ip = "localhost", port = 54321, startH2O = TRUE,
max_mem_size = '16g',nthreads=-1)
localH2O = h2o.init(ip = "localhost", port = 54321, startH2O = TRUE,
max_mem_size = '32g',nthreads=-1)
irisPath = system.file("extdata", "iris.csv", package = "h2o")
iris.hex = h2o.importFile(localH2O, path = irisPath)
h2o.deeplearning(x = 1:4, y = 5, data = iris.hex, activation = "Tanh",
hidden = c(10, 10), epochs = 5)
setwd("~/Dropbox/artigos/Meusartigos/IAA-WGC/Github/NB_GCs/Models_each_predictor")
#Poisson and NB regression using JAGS by Rafael S. de Souza, Bart Buelens, Ewan Cameron
#  Required libraries
library(rjags)
library(ggmcmc)
library(ggplot2)
library(ggthemes)
library(pander)
library(Cairo)
library(plyr)
library(MASS)
library(scales)
require(runjags)
# Function to allow parse labels in facet_wrap
facet_wrap_labeller <- function(gg.plot,labels=NULL) {
#works with R 3.0.1 and ggplot2 0.9.3.1
require(gridExtra)
g <- ggplotGrob(gg.plot)
gg <- g$grobs
strips <- grep("strip_t", names(gg))
for(ii in seq_along(labels))  {
modgrob <- getGrob(gg[[strips[ii]]], "strip.text",
grep=TRUE, global=TRUE)
gg[[strips[ii]]]$children[[modgrob$name]] <- editGrob(modgrob,label=labels[ii])
}
g$grobs <- gg
class(g) = c("arrange", "ggplot",class(g))
g
}
give.n <- function(x){
return(c(y = 0.5, label = length(x)))
# experiment with the multiplier to find the perfect position
}
################
# Script starts here
# Read data
GCS = read.csv(file="..//Dataset//GCs_full.csv",header=TRUE,dec=".",sep="")
GCS = subset(GCS, !is.na(MV_T))
#dim(GCS)
N_err<-GCS$N_GC_err
err_MV_T<-GCS$err_MV_T
N = nrow(GCS)
######## NB with errors ########################################################
MV_Tx = seq(from = 1.05 * min(GCS$MV_T),
to = 0.95 * max(GCS$MV_T),
length.out = 500)
jags.data <- list(
N_GC = GCS$N_GC,
MV_T = GCS$MV_T,
errN_GC = GCS$N_GC_err,
N = nrow(GCS),
err_MV_T = err_MV_T,
MV_Tx = MV_Tx,
M = 500
)
model.NB <- "model{
# Priors for regression coefficients
beta.0~dnorm(0,0.000001)
beta.1~dnorm(0,0.000001)
# Prior for size
size~dunif(0.001,5)
#
for (i in 1:N){
MV_T_true[i]~dunif(-26,-10)
}
# Likelihood function
for (i in 1:N){
MV_T[i]~dnorm(MV_T_true[i],1/err_MV_T[i]^2);
errorN[i]~dbin(0.5,2*errN_GC[i])
eta[i]<-beta.0+beta.1*MV_T_true[i]
#log(mu[i])<-max(-20,min(20,eta[i]))# Ensures that large beta values do not cause numerical problems.
log(mu[i])<-log(exp(eta[i])+errorN[i]-errN_GC[i])
p[i]<-size/(size+mu[i])
N_GC[i]~dnegbin(p[i],size)
# Prediction
etaTrue[i]<-beta.0+beta.1*MV_T_true[i]
log(muTrue[i])<-max(-20,min(20,etaTrue[i]))
pTrue[i]<-size/(size+muTrue[i])
prediction.NB[i]~dnegbin(pTrue[i],size)
#prediction.NB[i]~dnegbin(p[i],size)
# Discrepancy measures
YNew[i] ~ dnegbin(p[i],size)
expY[i] <- mu[i]
varY[i] <- mu[i] + pow(mu[i],2) / size
PRes[i] <-(N_GC[i] - expY[i])/sqrt(varY[i])
PResNew[i] <-(YNew[i] - expY[i])/sqrt(varY[i])
D[i]<-pow(PRes[i],2)
DNew[i]<-pow(PResNew[i],2)
}
Fit<-sum(D[1:N])
New<-sum(DNew[1:N])
# Prediction for new data
for (j in 1:M){
etax[j]<-beta.0+beta.1*MV_Tx[j]
log(mux[j])<-max(-20,min(20,etax[j]))
px[j]<-size/(size+mux[j])
prediction.NBx[j]~dnegbin(px[j],size)
}
}"
inits1 <- list(beta.0=rnorm(1,0,0.1),beta.1=rnorm(1,0,0.1),size=runif(1,0.1,5))
inits2 <- list(beta.0=rnorm(1,0,0.1),beta.1=rnorm(1,0,0.1),size=runif(1,0.1,5))
inits3 <- list(beta.0=rnorm(1,0,0.1),beta.1=rnorm(1,0,0.1),size=runif(1,0.1,5))
params <- c("beta.0","beta.1","size","PRes","MV_T_true","Fit","New","prediction.NBx")
#jags.neg <- jags.model(
#  data = jags.data,
#  inits = inits,
#  textConnection(model.NB),
#  n.chains = 3,
#  n.adapt=1000
#)
library(parallel)
cl <- makeCluster(3)
jags.neg <- run.jags(method="rjparallel", method.options=list(cl=cl),
data = jags.data,
inits = list(inits1,inits2,inits3),
model=model.NB,
n.chains = 3,
adapt=2000,
monitor=c(params),
burnin=20000,
sample=50000,
summarise=FALSE,
thin=5,
plots=FALSE
)
jagssamples.nb <- as.mcmc.list(jags.neg )
scale_fill_economist()+
)
Pred<-ggs(jagssamples.nb,family=c("New"))[,"value"]
Obs<-ggs(jagssamples.nb,family=c("Fit"))[,"value"]
sqrt(mean((Pred-Obs)^2))
# Dispersion parameter
require(scales)
Pres<-summary(as.mcmc.list(jags.neg, vars="PRes"),quantiles=0.5)$quantiles
Dipersion = sum(Pres^2)/(N-3)# beta.0, beta.1 and k, 3 parameters
Dipersion
jags.DIC <- jags.model(
data = jags.data,
inits = inits1,
textConnection(model.NB),
n.chains = 3,
n.adapt=2000
)
update(jags.DIC , 10000)
dicsamples.nb <- dic.samples(jags.DIC, params, n.iter = 25000,type="pD")
dicsamples.nb
975-25
995-5
citation(package = "rjags")
exp(2.19)
require(AMADA)
install_github("RafaelSdeSouza/AMADA")
require(devtools)
install_github("RafaelSdeSouza/AMADA")
require(AMADA)
require(AMADA)
corr<-Corr_MIC(SNIa,"pearson")
Fig1<-plotdendrogram(corr,"phylogram")
data("SNIa")
corr<-Corr_MIC(SNIa,"pearson")
Fig1<-plotdendrogram(corr,"phylogram")
install_github("RafaelSdeSouza/AMADA",dependencies=TRUE)
require(devtools)
install_github("RafaelSdeSouza/AMADA",dependencies=TRUE)
help("AMADA")
?AMADA
?"AMADA"
vignette("AMADA")
R CMD Rd2pdf AMADA
library(help="AMADA")
help("AMADA")
help(package="AMADA")
N = 10
M= 3
matrix(rnorm(N*M,mean=0,sd=1), N, M)
N = 100
M= 1000
M1<-matrix(rnorm(N*M,mean=0,sd=1), N, M)
M1
N = 10000
M= 1000
M1<-matrix(rnorm(N*M,mean=0,sd=1), N, M)
corr<-Corr_MIC(M1,"pearson")
Fig1<-plotdendrogram(corr,"phylogram")
corr
Fig1<-plotdendrogram(corr,"fan")
N = 5000
M= 100
M1<-matrix(rnorm(N*M,mean=0,sd=1), N, M)
corr<-Corr_MIC(M1,"pearson")
Fig1<-plotdendrogram(corr,"fan")
N = 5000
M= 500
M1<-matrix(rnorm(N*M,mean=0,sd=1), N, M)
corr<-Corr_MIC(M1,"pearson")
Fig1<-plotdendrogram(corr,"fan")
N = 5000
M= 100
M1<-matrix(rnorm(N*M,mean=0,sd=1), N, M)
corr<-Corr_MIC(M1,"pearson")
Fig1<-plotdendrogram(corr,"fan")
N = 50000
M= 100
M1<-matrix(rnorm(N*M,mean=0,sd=1), N, M)
corr<-Corr_MIC(M1,"pearson")
Fig1<-plotdendrogram(corr,"fan")
N = 100000
M= 100
M1<-matrix(rnorm(N*M,mean=0,sd=1), N, M)
corr<-Corr_MIC(M1,"pearson")
Fig1<-plotdendrogram(corr,"fan")
ptm <- proc.time()
corr<-Corr_MIC(M1,"pearson")
Fig1<-plotdendrogram(corr,"fan")
proc.time() - ptm
1.432+0.044
help(package="AMADA")
install.packages("GGally")
library("GGally", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
data(diamonds, package="ggplot2")
diamonds.samp <- diamonds[sample(1:dim(diamonds)[1],200),]
# Custom Example
pm <- ggpairs(
diamonds.samp[,1:3],
upper = list(continuous = "density", combo = "box"),
lower = list(continuous = "points", combo = "dot"),
color = "cut",
title = "Diamonds"
)
pm
pm <- ggpairs(
diamonds.samp[,1:3],
upper = list(continuous = "density", combo = "box"),
lower = list(continuous = "density", combo = "dot"),
color = "cut",
title = "Diamonds"
)
pm
ggpairs(
diamonds.samp[,1:3],
upper = list(continuous = "density", combo = "box"),
lower = list(continuous = "density"),
color = "cut",
title = "Diamonds"
)
ggpairs(
diamonds.samp[,1:3],
upper = list(continuous = "density"),
lower = list(continuous = "density"),
color = "cut",
title = "Diamonds"
)
ggpairs(
iris[,1:4],
upper = list(continuous = "density"),
lower = list(continuous = "density"),
color = "cut",
title = "Diamonds"
)
ggpairs(
iris[,1:4],
upper = list(continuous = "density"),
lower = list(continuous = "density")
)
ggpairs(
iris[,1:4],
upper = list(continuous = "cor"),
lower = list(continuous = "density")
)
pm <- ggpairs(
iris[,1:4],
upper = list(continuous = "cor"),
lower = list(continuous = "density"),
diag=list("density")
)
pm
ggpairs(
iris[,1:4],
upper = list(continuous = "cor"),
lower = list(continuous = "density"),
diag=list("bar'")
)
pm <- ggpairs(
iris[,1:4],
diag=list("bar"),
upper = list(continuous = "cor"),
lower = list(continuous = "density")
)
pm
pm <- ggpairs(
iris[,1:4],
diag=list("bar"),
upper = list(continuous = "cor"),
lower = list(continuous = "hist")
)
pm
pm <- ggpairs(
iris[,1:4],
diag=list("continuous"),
upper = list(continuous = "cor"),
lower = list(continuous = "density")
)
pm
model<-"model{
#1. Priors
b0~dnorm(0,1e-5)
b1~dnorm(0,1e-5)
#c0~dnorm(0,1e-5)
#c1~dnorm(0,1e-5)
#2. Likelihood
for(i in 1:N){
logit(mu[i]) <- b0 + b1*x[i]
#   sigma[i]<-exp(c0+c1*x[i])
phi~dgamma(0.01,0.01)
#  p[i] <-max(0.000001,((1-mu[i])*mu[i]*mu[i]-mu[i]*sigma[i]^2)/sigma[i])
#  q[i] <- max(0.00001,(1-mu[i])*(mu[i]-mu[i]*mu[i]-sigma[i])/sigma[i])
p[i]<-mu[i]*phi
q[i]<-(1-mu[i])*phi
Y[i] ~ dbeta(p[i],q[i])
#3. Prediction
prediction[i]~dbeta(p[i],q[i])
}
}"
params <- c("b0","b1","prediction")
inits1=list(b0=rnorm(1,0,1),b1=rnorm(1,0,1),c0=rnorm(1,0,1),c1=rnorm(1,0,1))
inits2=list(b0=rnorm(1,0,1),b1=rnorm(1,0,1),c0=rnorm(1,0,1),c1=rnorm(1,0,1))
inits3=list(b0=rnorm(1,0,1),b1=rnorm(1,0,1),c0=rnorm(1,0,1),c1=rnorm(1,0,1))
library(parallel)
cl <- makeCluster(3)
jags.logit <- run.jags(method="rjparallel",
data = jags.data,
inits = list(inits1,inits2,inits3),
model=model,
n.chains = 3,
adapt=1500,
monitor=c(params),
burnin=1000,
sample=5000,
summarise=FALSE,
plots=FALSE
)
setwd("~/Dropbox/artigos/Meusartigos/IAA-WGC/Github/Beta_regression")
# Bayesian  Logistic Regression using JAGS
#  Required libraries
library(rjags)
library(ggmcmc)
library(ggplot2)
library(ggthemes)
library(pander)
library(Cairo)
library(plyr)
library(MASS)
library(scales)
library(plyr)
require(gdata)
require(runjags)
require(gdata)
#Read the already clean dataset
data.1= read.table(file="FiBY_escape_data_all.dat",header=FALSE)
colnames(data.1)<-c("redshift","fEsc","Mvir","Mstar","Mgas","QHI","sfr_gas",
"sfr_stars","ssfr_gas","ssfr_stars","baryon_fraction",
"spin","age_star_mean","age_star_max","age_star_min")
data.2<-data.1[data.1$redshift==15.20530,]
data.3<-data.2[data.2$fEsc>0,]
jags.data <- list(Y= data.3$fEsc,
N = nrow(data.3),
x=(data.3$Mgas-mean(data.3$Mgas))/sd(data.3$Mgas)
#                  x=log(data.3$Mvir,10)
)
model<-"model{
#1. Priors
b0~dnorm(0,1e-5)
b1~dnorm(0,1e-5)
#c0~dnorm(0,1e-5)
#c1~dnorm(0,1e-5)
#2. Likelihood
for(i in 1:N){
logit(mu[i]) <- b0 + b1*x[i]
#   sigma[i]<-exp(c0+c1*x[i])
phi~dgamma(0.01,0.01)
#  p[i] <-max(0.000001,((1-mu[i])*mu[i]*mu[i]-mu[i]*sigma[i]^2)/sigma[i])
#  q[i] <- max(0.00001,(1-mu[i])*(mu[i]-mu[i]*mu[i]-sigma[i])/sigma[i])
p[i]<-mu[i]*phi
q[i]<-(1-mu[i])*phi
Y[i] ~ dbeta(p[i],q[i])
#3. Prediction
prediction[i]~dbeta(p[i],q[i])
}
}"
params <- c("b0","b1","prediction")
inits1=list(b0=rnorm(1,0,1),b1=rnorm(1,0,1),c0=rnorm(1,0,1),c1=rnorm(1,0,1))
inits2=list(b0=rnorm(1,0,1),b1=rnorm(1,0,1),c0=rnorm(1,0,1),c1=rnorm(1,0,1))
inits3=list(b0=rnorm(1,0,1),b1=rnorm(1,0,1),c0=rnorm(1,0,1),c1=rnorm(1,0,1))
library(parallel)
cl <- makeCluster(3)
jags.logit <- run.jags(method="rjparallel",
data = jags.data,
inits = list(inits1,inits2,inits3),
model=model,
n.chains = 3,
adapt=1500,
monitor=c(params),
burnin=1000,
sample=5000,
summarise=FALSE,
plots=FALSE
)
model<-"model{
#1. Priors
b0~dnorm(0,1e-5)
b1~dnorm(0,1e-5)
#c0~dnorm(0,1e-5)
#c1~dnorm(0,1e-5)
phi~dgamma(0.01,0.01)
#2. Likelihood
for(i in 1:N){
logit(mu[i]) <- b0 + b1*x[i]
#   sigma[i]<-exp(c0+c1*x[i])
#  p[i] <-max(0.000001,((1-mu[i])*mu[i]*mu[i]-mu[i]*sigma[i]^2)/sigma[i])
#  q[i] <- max(0.00001,(1-mu[i])*(mu[i]-mu[i]*mu[i]-sigma[i])/sigma[i])
p[i]<-mu[i]*phi
q[i]<-(1-mu[i])*phi
Y[i] ~ dbeta(p[i],q[i])
#3. Prediction
prediction[i]~dbeta(p[i],q[i])
}
}"
params <- c("b0","b1","prediction")
inits1=list(b0=rnorm(1,0,1),b1=rnorm(1,0,1),c0=rnorm(1,0,1),c1=rnorm(1,0,1))
inits2=list(b0=rnorm(1,0,1),b1=rnorm(1,0,1),c0=rnorm(1,0,1),c1=rnorm(1,0,1))
inits3=list(b0=rnorm(1,0,1),b1=rnorm(1,0,1),c0=rnorm(1,0,1),c1=rnorm(1,0,1))
library(parallel)
cl <- makeCluster(3)
jags.logit <- run.jags(method="rjparallel",
data = jags.data,
inits = list(inits1,inits2,inits3),
model=model,
n.chains = 3,
adapt=1500,
monitor=c(params),
burnin=1000,
sample=5000,
summarise=FALSE,
plots=FALSE
)
predscape<-summary(as.mcmc.list(jags.logit, vars="prediction"))
predscape<-predscape$quantiles
predscape
x=(data.3$Mgas-mean(data.3$Mgas))/sd(data.3$Mgas)
plot(x,predscape[,3])
plot(x,data.3$fEsc)
min(data.3$fEsc)
plot(data.3$fEsc,predscape[,3])
plot(data.3$fEsc,predscape[,3],log="true")
plot(data.3$fEsc,predscape[,3],y=log
)
plot(data.3$fEsc,predscape[,3],log="y")
plot(data.3$fEsc,predscape[,3],log="xy")
